//
//  keysign.c
//  
//
//  Created by Dennis Mirante on 5/1/14.
//
//


#include <stdio.h>
#include <stdlib.h>
#include <openssl/rsa.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/conf.h>
#include <openssl/x509v3.h>


/*
 * Structure used to contain validity parameters that confirm something about the
 * user the certificate was generated by.  Some parameters, such as start_time
 * and end_time are used when generating the certificate and are not used by
 * keyverify to verify it.  The X509 routines invoked by keysign will make sure
 * the certificate has not expired.
 */

struct issuer{
    long serial_number;         /* certificate serial number */
    long start_time;            /* certificate not good before this time */
    long end_time;              /* certificate not good after this time */
    char country[10];           /* country of generator */
    char organization[70];      /* generator's organization */
    char common_name[70];       /* generator's name */
};


void usage ( void ) {
    fprintf ( stderr, "\n\nUsage: ./keysign publickey.txt secretkey.txt validityparameters.txt\n");
    fprintf ( stderr, "where:\n" );
    fprintf ( stderr, "       publickey.txt is a file in PEM format containing the RSA public key\n" );
    fprintf ( stderr, "       secretkey.txt is a file in PEM format containing the RSA private key\n" );
    fprintf ( stderr, "       validityparameters.txt is a binary file containing information about the public key owner\n");
    fprintf ( stderr, "\n" );
    fprintf ( stderr, "Output is a RSA Hashed SHA256 signed X509 certificate in PEM format\n" );
    fprintf ( stderr, "\n" );
    fprintf ( stderr, "Program output may be redirected from stdout using the > symbol\n" );
    fprintf ( stderr, "\n" );
}



int main( int argc, char * argv[] ) {
    
    /* Structure common to generator and user of certificate used in validating it */
    struct issuer id;
    
    /* descriptors used for various files */
    FILE *issuer_params;
    FILE *public;
    FILE *private;
    
    /* Public and Private key structures.  Any allocated memory must be freed after use */
    EVP_PKEY *pub_key;
    EVP_PKEY *pri_key;
    
    RSA *rsa_pub;
    RSA *rsa_pri;
    
    
    /* helper variables */
    int bytes;
    
    OpenSSL_add_all_algorithms();

    
    /* check command line arguments for validity */
    
    if ( argc != 4 ) {
        /* must have public key, private key, and keyfile owner information files */
        usage();
        exit (1);
    }

    /* open required files. if they dont exist, quit with error */


    public = fopen( argv[1], "rb" );
    if ( public == NULL ) {
        fprintf( stderr, "Bad RSA Public Key File Name or File Doesn't Exist\n" );
        exit(1);
    }
    
    private = fopen( argv[2], "rb" );
    if ( private == NULL ) {
        fprintf( stderr, "Bad RSA Private File Name or File Doesn't Exist\n" );
        exit(1);
    }
    
    issuer_params = fopen( argv[3], "rb" );
    if ( !issuer_params ){
        fprintf( stderr, "Bad Public Key Owner Information File Name or File Doesn't Exist\n");
        exit(1);
    }

    /* Read the public key and close the file */
    rsa_pub = PEM_read_RSAPublicKey( public, NULL, NULL, NULL );
    if ( rsa_pub == NULL ) {
        fprintf( stderr, "Bad RSA Public Key File\n");
        exit(1);
    }

    fclose ( public );
    
    /* allocate a key structure */
    pub_key = EVP_PKEY_new();
    if( pub_key == NULL ) {
        fprintf( stderr, "pub_key = EVP_PKEY_new() failed\n" );
        exit(1);
    }
    
    /* assign the rsa key to the key structure */
    if ( EVP_PKEY_assign_RSA( pub_key, rsa_pub ) == 0 ) {
        fprintf( stderr, "EVP_PKEY_assign_RSA( pub_key, rsa_pub ) failed\n" );
        exit(1);
    }
    
    /* Read the private key and close the file */
    rsa_pri = PEM_read_RSAPrivateKey( private, NULL, NULL, NULL );
    if ( rsa_pri == NULL ){
        fprintf( stderr, "Bad RSA Private Key File\n");
        exit(1);
    }
    
    fclose( private );

    pri_key = EVP_PKEY_new();
    if( pri_key == NULL ) {
        fprintf( stderr, "pri_key = EVP_PKEY_new() failed\n" );
        exit(1);
    }

    if ( EVP_PKEY_assign_RSA( pri_key, rsa_pri ) == 0 ) {
        fprintf( stderr, "EVP_PKEY_assign_RSA( pri_key, rsa_pri ) failed\n" );
        exit(1);
    }
    
    
    
    /* Get binary information from key owner information file and initialize issuer structure with it */
    bytes = fread( &id, sizeof(struct issuer ), 1, issuer_params );
    if ( bytes == 0 ) {
        fprintf( stderr, "Bad Public Key Owner Information File\n");
        exit(1);
    }

    fclose ( issuer_params );

 
    /*
     * We now have Public Key, Private Key, and Issuer Identification information in memory.
     * This is all the information necessary to create a certificate.
     */
    

    /* Use x509 structure to represent x509 certificate in memory */
    /* Generate instance of X509 certificate.  Allocated memory must be freed after use */

    X509 * x509;
    x509 = X509_new();

    if( x509 == NULL ){
        fprintf( stderr, "X509_new() Failed \n" );
        exit(1);
    }
    
    /* Set the properties of the certificate using the Issuer information and X509_* functions */
    
    X509_set_version( x509, 3);
    
    /* Set the serial number of the certificate */
    ASN1_INTEGER_set(X509_get_serialNumber(x509), id.serial_number);

    /* Specify the span of time during which the certificate is valid, using Issuer Information */
    X509_gmtime_adj(X509_get_notBefore(x509), id.start_time);
    X509_gmtime_adj(X509_get_notAfter(x509), id.end_time);
    


    /* Set the public key for our certificate using the public key we read */

    X509_set_pubkey( x509, pub_key );

    /* This is a self-signed certificate.  Set the name of the issuer to the name of the subject.
     * Get the subject name portion of the certificate and fill in the fields identifying the
     * Issuer from the Issuer information we previously read in.
     */

    X509_NAME * name;

    if( ! ( name = X509_get_subject_name( x509 ))) {
        fprintf( stderr, "X509_get_subject_name_failed\n" );
        exit(1);
    }


    /* Set the Country, Organization, and Name fields in the subject to be those of the Issuer */
    X509_NAME_add_entry_by_txt(name, "C",  MBSTRING_ASC, (unsigned char *) id.country, -1, -1, 0);
    X509_NAME_add_entry_by_txt(name, "O",  MBSTRING_ASC, (unsigned char *) id.organization, -1, -1, 0);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (unsigned char *) id.common_name, -1, -1, 0);

    /* Store the issuer name back into the certificate */
    X509_set_issuer_name(x509, name);

    /* 
     * Sign the certificate with the private key using a DSA signature
     * The DSA signature is returned in a SHA1 structure
     */
        
    const EVP_MD *dgAlg = EVP_get_digestbyname("SHA256");
        
    if ( dgAlg == NULL ) {
        fprintf( stderr, "Digest Algorithm Is Null\n");
        exit(1);
    }
    
    if( ! X509_sign( x509, pri_key, dgAlg ) ) {
        fprintf( stderr, "Failed To Sign The Certificate\n");
        exit(1);
    };

 
    /*  Write the certificate to stdout using PEM_write_X509 function */
 
    if ( ! PEM_write_X509( stdout, x509 ) ) {
        fprintf( stderr, "Failed To Write Certificate\n" );
        exit(1);
    }
    
    /* return all memory allocated to OPENSSL structures */
    EVP_PKEY_free( pub_key );
    EVP_PKEY_free( pri_key );
    X509_free(x509);

    return (0);
}


