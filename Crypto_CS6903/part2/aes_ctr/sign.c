//
//  sign.c
//  
//
//  Created by Dennis Mirante on 4/15/14.
//
//

#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/hmac.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "ctrhdr.h"


void usage ( void ) {
    fprintf ( stderr, "\n\nUsage: ./sign hmackey hmactype filetosign signedfile {-t}\n");
    fprintf ( stderr, "where:\n" );
    fprintf ( stderr, "       hmackey is the file containing the key generated by ./keygen in hex format\n" );
    fprintf ( stderr, "       hmactype is the type of HMAC desired: md5, sha1, sha224, sha256, sha384, or sha512\n");
    fprintf ( stderr, "       filetosign is the input file for which the HMAC will be generated\n" );
    fprintf ( stderr, "       signedfile is output file with header followed by contents of the filetosign file");
    fprintf ( stderr, "       -t is an optional parameter that causes the display of collected timing statistics\n" );
    fprintf ( stderr, "\n" );
    fprintf ( stderr, "Example invocations:\n");
    fprintf ( stderr, "                      ./sign sha256key.txt sha256 ciphertext.txt signedciphertext.txt\n" );
    fprintf ( stderr, "                      ./sign sha512key.txt sha512 ciphertext.txt signedciphertext.txt -t\n" );
    fprintf ( stderr, "\n" );
    fprintf ( stderr, "The header portion of the signedfile is filled in with the timestamp and calculated SHA256 HMAC code\n" );
    fprintf ( stderr, "\n" );
}



// get hex input character by character from file to build byte array.  Maximum array size returned is
// buf points to block buffer, len will be set with number of bytes converted.  This is used for key input
// and should be replaced.

int getHEXinput ( FILE * file,  unsigned char *buf, int *len ) {
    
    int chr;
    
    unsigned char * ptr = buf;
    
    /* Hex string for conversion will be built here.   Number of bytes is Maximum expected symbol count / 2 */
    char hex_inp [MAX_HEX_INP_SYM / 2 + 1];
    
    char * hex_inp_ptr;
    
    int hex_str_len;
    
    hex_str_len = 0;
    
    /* initialize number of converted bytes to 0 */
    *len = 0;
    
    /* build hex input string for conversion */
    
    /*
     this loop reads hex character data from the file until either EOF is encountered
     or a hex data buffer to be converted has been filled to the maximu number of characters allowed.
     */
    
    while ( hex_str_len < MAX_HEX_INP_SYM / 2 ) {
        
        chr = fgetc( file );
        
        /* quit if file is exhausted */
        
        if ( chr == EOF ) break;
        
        /* ignore all characters other than hex chars 0-9, a-f, A-F */
        
        if ( ( chr >= '0' && chr <= '9') || ( chr  >= 'A' && chr <= 'F' ) || (chr >= 'a' && chr <= 'f') ){
            
            /* store char in hex data buffer being built and bump the pointer */
            
            hex_inp[ hex_str_len ] = (char) chr;
            hex_str_len++;
        }
    }
    
    if ( hex_str_len == 0 ) {
        /* nothing found, return with normal status */
        return 0;
    }
    else if ( hex_str_len % 2 ){
        /* file is exhausted, uneven number of characters found, return error status */
        return 1;
    }
    else {
        /* terminate hex characters in buffer just built with null so its content can be processed as string */
        hex_inp[ hex_str_len ] = '\0';
    }
    
    /* set pointer to beginning of string data just collected */
    hex_inp_ptr = &hex_inp[0];
    
//    fprintf( stderr, " key input = %s\n", hex_inp );
    
    /* convert all characters in hex string to byte values and store in reserved block */
    
    while ( sscanf( hex_inp_ptr, "%02x", &chr ) == 1 ) {
        hex_inp_ptr = hex_inp_ptr + 2;
        //        fprintf( stderr, "char = %d\n", chr );
        (*len)++;
        *ptr = ( unsigned char ) chr;
        ptr++;
    }
    
    /* return with number of hex data byes converted in *len and converted data in buf */
    
    return 0;
    
}


// generate HMAC tag for file contents, starting from the first data position in the filetosign input file up to the EOF
// arguments are pointer to error file, pointer to file to be signed, pointer to key, key length, pointer to where tag is to be stored, pointer to
// where generated tag's length is to be stored, pointer to structure where timestamp data is to be returned, pointer to where elapsed time
// generating the tag is to be stored, pointer to structure containing the attributes of the HMAC

int signfile ( FILE * stderr, FILE * filetosign, FILE * signedfile, unsigned char * key, int key_len, unsigned char * tag, unsigned int * tag_len, TIMESTAMP_STRUCT * ts, clock_t * ctime, struct encode_attr * attr_ptr   )
{
    
    /* allocate 32k read buffer for reading file contents */
    int bufSize = 32768;
    
    /* number of bytes read from file */
    int bytesRead = 0;
    
    /* variables used for timing elapsed time for tag generation */
    clock_t start_t, end_t;
    
    /* struct used by openssl tag generation routines */
    HMAC_CTX ctx;
    
    /* status returned by openssl HMAC routines */
    int status;
    
    /* allocate the buffer for file reading */
    unsigned char * buffer = malloc( bufSize );
    
    if( !buffer ) {
        fprintf( stderr, "signfile - failed to allocate buffer\n");
        return (1);
    }

    
    /* initialize the openssl HMAC structure */
    HMAC_CTX_init( &ctx );
    
    /* initialize openssl HMAC tag generation routine */
    status = HMAC_Init_ex( &ctx, key, key_len, attr_ptr->md, NULL );
    
    if ( status == 0 ) {
        fprintf( stderr, "status = %d\n", status );
        fprintf( stderr, "signfile - HMAC_Init_ex Failed\n" );
        return (1);
    }
    

    
    while( ( bytesRead = fread( buffer, 1, bufSize, filetosign ) ) ) {

        /* copy contents of file to sign into signed file */
        fwrite( buffer, 1, bytesRead, signedfile );
        
        /* start timing  here */
        start_t = clock();

        /* authenticate chunk of file */
        status = HMAC_Update( &ctx, buffer, bytesRead );

        /* end timing here and accumulate */
        end_t = clock();
        *ctime = *ctime + (end_t - start_t);
        
        if ( status == 0 ) {
            fprintf( stderr, "signfile - HMAC_Update Failed\n" );
            return (1);
        }
    }
    
    /* get timestamp and authenticate */
    
    ts->timestamp_bin = (unsigned) time(NULL);
    sprintf( (char *) buffer, TIMESTAMP_FORMAT, ts->timestamp_bin );
    sprintf( (char *) &(ts->timestamp_hex), TIMESTAMP_FORMAT, ts->timestamp_bin );
    bytesRead = TIMESTAMP_FLD_SZ * 2;
    
    /* authenticate timestamp */
    start_t = clock();
    status = HMAC_Update( &ctx, buffer, bytesRead );
    
    /* end timing here and accumulate */
    end_t = clock();
    *ctime = *ctime + (end_t - start_t);
    
    if ( status == 0 ) {
        fprintf( stderr, "signfile - HMAC_Update Failed (TIMESTAMP)\n" );
        return (1);
    }
    
    /* start timing  here */
    start_t = clock();
    
    /* get generated tag and its length */
    status = HMAC_Final(&ctx, tag, tag_len );

    /* end timing here and accumulate */
    end_t = clock();
    *ctime = *ctime + (end_t - start_t);
    
    if ( status == 0 ) {
        fprintf( stderr, "signfile - HMAC_Final Failed\n" );
        return (1);
    }
    
    /* openssl routine erases key and other data from ctx and releases openssl allocated resources */
    HMAC_CTX_cleanup( &ctx );
    
    free(buffer);
    
    return 0;
}      



int main(int argc, char* argv[]){
    
    /* descriptors used for various files */
    FILE *key_file;
    FILE *filetosign;
    FILE *signedfile;
    
    /* byte length of converted hex data */
    int in_blk_len;
    
    /* key data */
    unsigned char key     [KEY_MAX_LENGTH];
    
    /* tag data */
    unsigned char tag [MAX_HMAC_TAG_SIZE];
    
    unsigned int tag_len;
    
    /* returned timestamp values in hex and binary */
    TIMESTAMP_STRUCT timestamp;
    
    /* helper variables for returned status, iteration */
    int status;
    int i;
    
    /* timing flag, initialized to assume no display of timing statistics */
    int timing = TN;
    
    /* clock variables */
    clock_t  total_t;
    double cpu_time;
    
    /* argument for processing key type in program invocation line */
    struct encode_arg   arg;
    
    /* returned attributes for key type */
    struct encode_attr  hmac_attrib;

    
    /* initialize total time for possible use */
    total_t = (clock_t) 0;
    
    /* check command line arguments for validity */
    
    if ( argc < 5  || argc > 6 ) {
        /* must have at least key, HMAC type, filetosign, and signedfile files as parameters, with optional timing parameter */
        usage();
        exit (1);
    }
    else if ( argc == 6) {
        /* 5th parameter specified, check to make sure it is timing parameter */
        if ( strcmp ( argv[5], "-t" )  == 0 ){
            /* print timing statistics */
            timing = TY;
        }
        else {
            /* bad timing parameter */
            usage();
            exit(1);
        }
    }
    
    /* copy the string HMACtype specification and pass it for parsing */
    
    arg.type = LIT;
    strcpy( arg.arg.str, argv[2] );
    
    status = get_encode_attr ( stderr, 0, &arg, &hmac_attrib );
    if ( status ){
        usage();
        exit(1);
    }

    /* open required files. if they dont exist, quit with error */
    
    key_file = fopen( argv[1], "rb" );
    if ( key_file == NULL ) {
        fprintf( stderr, "Bad Key File Name %s or File Doesn't Exist\n" , argv[1]);
        exit(1);
    }
    
    
    filetosign = fopen( argv[3], "r" );
    if ( filetosign == NULL ) {
        fprintf( stderr, "Bad filetosign File Name %s or File Doesn't Exist\n", argv[3] );
        exit(1);
    }
    
    signedfile = fopen( argv[4], "w+" );
    if ( signedfile == NULL ) {
        fprintf( stderr, "Bad signedfile File Name %s\n", argv[4] );
        exit(1);
    }
    
    
    /* Read key */
    
    status = getHEXinput ( key_file,  key, &in_blk_len );
    
    /* quit on size error */  /* adjust later for selected key */
    if ( status /*|| (in_blk_len != HMAC_KEY_SIZE ) */ ) {
        fprintf( stderr, "Bad Key Hex Data\n" );
        exit(1);
    }
    
    fclose( key_file );
    
    /* sign the file, parameterize the key size later */
    /* check no field overflow possible later */
    
    /* Write out reserved HMAC header area skeleton to output file. Initially 0, may want to make content randomized */
    
    i = 0;
    while ( i < HMAC_HDR_SIZE ){
        fprintf( signedfile, "%02x", 0);
        i++;
    }
    
    /* terminate HMAC header with \n */
    
    fprintf( signedfile, "%c", '\n' );

    /* go sign the file, add it to output file, and generate & use timestamp */
    
    status = signfile ( stderr, filetosign, signedfile, key, in_blk_len, tag, &tag_len, &timestamp, &total_t, &hmac_attrib );
    if ( status ) {
        fprintf( stderr, "HMAC Tag Generation Failed\n");
        exit (1);
    }
 
    /* done with input file */
    fclose( filetosign );
    
    /* write prefix and suffix verification sequence to header to authenticate it in verify */
    status = fseek( signedfile, F_PREFIX_POS, SEEK_SET );
    if ( status ) {
        fprintf( stderr, "Bad %s File - Could Not Seek To PREFIX Position In Header\n", argv[4] );
        exit (1);
    }

    fprintf( signedfile, PREFIX_FORMAT, PREFIX_VALUE );
    
    status = fseek( signedfile, F_SUFFIX_POS, SEEK_SET );
    if ( status ) {
        fprintf( stderr, "Bad %s File - Could Not Seek To SUFFIX Position In Header\n", argv[4] );
        exit (1);
    }
    
    fprintf( signedfile, SUFFIX_FORMAT, SUFFIX_VALUE );
    
    
    
    /* write the hmac type */
    status = fseek( signedfile, F_HMAC_TYPE_POS, SEEK_SET );
    if ( status ) {
        fprintf( stderr, "Bad %s File - Could Not Seek To HMAC TYPE Position In Header\n", argv[4] );
        exit (1);
    }
    
    fprintf( signedfile, HMAC_TYPE_FORMAT, hmac_attrib.type );
    
    

    /* skip to timestamp reserved spot in header */
    
    status = fseek( signedfile, F_TIMESTAMP_POS, SEEK_SET );
    if ( status ) {
        fprintf( stderr, "Bad %s File - Could Not Seek To Timestamp Position In Header\n", argv[4] );
        exit (1);
    }

    /* copy the timestamp to header in hex format */
    
    for (i = 0; i < TIMESTAMP_FLD_SZ * 2 ; i++ ) {
        fprintf( signedfile, "%c", timestamp.timestamp_hex[i]);
    }
    
    /* position to tag length field in header and write it */
    
    status = fseek( signedfile, F_HMAC_LEN_POS, SEEK_SET );
    
    if ( status ) {
        fprintf( stderr, "Bad %s File - Could Not Seek To HMAC Tag Length Position In Header\n", argv[4] );
        exit (1);
    }
    
    fprintf( signedfile, HMAC_LENGTH_FORMAT, tag_len );
    
    
    /* position to tag field and write tag */

    status = fseek( signedfile, F_HMAC_TAG_POS, SEEK_SET );
    
    if ( status ) {
        fprintf( stderr, "Bad %s File - Could Not Seek To HMAC TAG Position In Header\n", argv[4] );
        exit (1);
    }

    /* trap tag length overflow */
    
    if ( tag_len > MAX_HMAC_TAG_SIZE ) {
        fprintf( stderr, "Tag Generation Error - HMAC Tag Longer Than Expected Size\n" );
        fprintf( stderr, "Expected Size = %d  Calcualted Size = %d", MAX_HMAC_TAG_SIZE, tag_len );
        exit (1);
    }
    
    /* write out tag to file */
    
    for ( i = 0; i < tag_len; i++ ){
        fprintf( signedfile, "%02x", tag[ i ] );
    }
    
    /* Print out timing values if TY specified */
    if ( timing == TY ) {
        cpu_time = ((double) total_t) / CLOCKS_PER_SEC;
        fprintf( stderr, "Total tag generation time: %f\n", cpu_time );
    }

    fclose( signedfile );
    
    return 0;
    
}



